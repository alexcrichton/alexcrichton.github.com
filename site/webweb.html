<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
  <title>code.alex</title>
  <link href="stylesheets/screen.css?1237521152" media="screen" rel="stylesheet" type="text/css" />
<link href="stylesheets/style.css?1238036462" media="screen" rel="stylesheet" type="text/css" />
<link href="stylesheets/menus.css?1238037757" media="screen" rel="stylesheet" type="text/css" />
  <script src="javascripts/jquery.js?1238018364" type="text/javascript"></script>
<script src="javascripts/menubar.js?1238037684" type="text/javascript"></script>
</head>
<body>
<div id="header">
  <div id="logo">
    <a href="index.html" class="nohighlight"><img alt="code.alex" src="images/logo.png?1237526184" /></a>
  </div>
  <ul id="topnav" class="menubar">
    <li class="top"><a href="index.html">Home</a></li>
<li class="top"><a href="java.html">Java</a>
  <ul class="down">
    <li class="sub"><a href="java.html#apps">Applications</a>
      <ul>
        <li><a href="jars/mds.jar">mds</a></li>
        <li><a href="jars/calculator.jar">calculator</a></li>
        <li><a href="jars/ciphers.jar">ciphers</a></li>
        <li><a href="jars/himcm07.jar">himcm07</a></li>
        <li><a href="jars/lathe.jar">lathe</a></li>
        <li><a href="jars/mastermind.jar">mastermind</a></li>
        <li class="sub"><a href="jars/numberspeller.jar">numberspeller</a>
          <ul>
            <li><a href="bignum.html">Bignum</a></li>
          </ul>
        </li>
        <li><a href="jars/pong.jar">pong</a></li>
        <li><a href="jars/riemann.jar">riemann</a></li>
        <li><a href="jars/sudoku.jar">sudoku</a></li>
        <li><a href="jars/tetris.jar">tetris</a></li>
        <li><a href="jars/track.jar">track</a></li>
      </ul>
    </li>
    <li><a href="java.html#competitions">Competitions</a></li>
    <li><a href="java.html#litvin">Litvin</a></li>
    <li><a href="java.html#eclipse">Eclipse</a></li>
  </ul>
</li>
<li class="top"><a href="ruby.html">Ruby</a></li>
<li class="top"><a href="webweb.html">Blagoblag</a></li>
<li class="top"><a href="testing.html">Testing</a>
  <ul class="down">
    <li class="sub">This
      <ul>
        <li class="sub">is
          <ul>
            <li class="sub">a
              <ul>
                <li class="sub">long
                  <ul>
                    <li class="sub">menu
                      <ul>
                        <li>congrats on</li>
                        <li>reaching the</li>
                        <li>end</li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</li>

  </ul>
</div>

<div id="container" class="span-24 push-1">
  <div id="page" class="span-17">
    <h1 class="separator">Interhacks</h1>
<h2 class="separator">Need Unfiltered, Free
  Blagospheres? <a href="#" onclick="$('#blagosphere').slideToggle('fast'); return false;">[show/hide]</a></h2>
<div id="blagosphere" style="display:none">
  <div>
  SSH tunnel out! Applications probably can't filter encrypted traffic (they definitely can't read it).
  <br /><br/>
  Now this assumes a few things:
  <ol>
    <li>You have an SSH server w/ free unfiltered internet and control over the SSH daemon</li>
    <li>You have mastered the concept of common sense</li>
    <li>You use Linux, or are smart enough to understand the instructions anyway</li>
  </ol>
</div>
<hr/>
<h4>1. Create the Connection...</h4>

<p>
  This is ridiculously simple, yet will probably not work...
</p>
<pre>
  ssh <em>hostname</em>
</pre>
<p>
  If it worked, huzzah! You're lucky... go on to next section. <br />
  If not, see if the items below can't help.
</p>
<strong>Port 22 blocked?</strong> <a href="#" onclick="$('#port22').slideToggle(); return false;">[show/hide]</a>
<div id="port22" style="display:none;">
  Try a different one! Most likely port 443. It's normally dedicated for SSL traffic and is rarely blocked, unless they
  don't want you doing secure things online for some reason... Just make sure the SSH server is listening on this port.
  <pre>
    ssh <em>hostname</em> -p 443
  </pre>
</div>

<br />
<strong>Connections dropped and must use proxy to get
  Webblags?</strong> <a href="#" onclick="$('#proxy').slideToggle(); return false;">[show/hide]</a>
<div id="proxy" style="display:none;">
  A nifty tool called <a href="http://www.agroman.net/corkscrew/">corkscrew</a> is available to pipe SSH connections
  through proxies. To enable the use
  of this, in your .ssh/config file, you'll have to add the following line to the host options:
  <pre>
    # ~/.ssh/config
    Host <em>alias</em>
      Hostname ...
      User ...
      ...
      ProxyCommand /usr/bin/corkscrew <em>proxyhostname proxyport</em> %h %p
      ...
  </pre>
  With the %h and %p and all. Just replace the italicized and dotted stuff. And then:
  <pre>
    ssh <em>alias</em>
  </pre>
</div>

<br />
<strong>Connections dropped and proxy requires simple
  authentication?</strong> <a href="#" onclick="$('#simple').slideToggle(); return false;">[show/hide]</a>
<div id="simple" style="display:none;">
  If basic authentication is used, then on the <code>ProxyCommand</code> line in the <code>.ssh/config</code> file,
  after <code>%p</code> you'll have to add a filename, like <code>~/.ssh/authfile</code> which has your username
  and password in the format of <code>username:password</code> on the first line. That's all you need in the file.<br />

  <hr />
  <pre>
    # ~/.ssh/config
    Host <em>alias</em>
      ...
      ProxyCommand /usr/bin/corkscrew <em>proxyhostname proxyport</em> %h %p ~/.ssh/authfile
  </pre>
  <pre>
    # ~/.ssh/authfile
    admin:password
  </pre>
  Then again, ssh out normally and slap on whatever options you want:
  <pre>
    ssh <em>alias</em>
  </pre>
</div>

<br />
<strong>Connections dropped and proxy requires NTLM
  authentication?</strong> <a href="#" onclick="$('#ntlm').slideToggle(); return false;">[show/hide]</a>
<div id="ntlm" style="display:none">
  If NTLM authentication is used, then things get more interesting. Corkscrew can't do it, so use another proxy! A
  little program called <a href="http://sourceforge.net/project/showfiles.php?group_id=197861">CNTLM</a> is it's own
  proxy which attaches the authentication information to all packet requests.
  With this, just direct your corkscrew to the CNTLM proxy, hostname being localhost, your computer. Of course you'll
  have to configure CNTLM as well and start it up beforehand and leave it running throughout...
  <hr />
  Example <code>/etc/cntlm.conf</code>: <a href="#" onclick="$('#cntlmconf').slideToggle(); return false;">[show/hide]</a>
  <pre id="cntlmconf" style="display:none;">
    #
    # Cntlm Authentication Proxy Configuration
    #
    # NOTE: all values are parsed literally, do NOT escape spaces,
    # do not quote. Use 0600 perms if you use plaintext password.
    #

    Username        riceti # your username
    Domain          DMPS   # some domain name... try to get somehow
    # Regenerate these hashes through 'cntlm -H' after filling in the username
    # and domain for the network.
    PassLM          8F21BDAFB3313C1A3DD9A4DC8CB1F253
    PassNT          702AA998C957DF5EDC53D0F2DA69469C
    PassNTLMv2      8D6CAA261D33971763D79A41AC21F9C3    # Only for user 'riceti', domain 'DMPS'
    #Password      ...# Put your plaintext password here if you'd rather not use hashes

    #Workstation    netbios_hostname   # Should be auto-guessed

    Proxy      hs-proxy.dmps.k12.ia.us:80 # The proxy here which requires authentication

    #
    # This is the port number where Cntlm will listen
    #
    Listen     3128

    #
    # If you wish to use the SOCKS5 proxy feature as well, uncomment
    # the following option, SOCKS5. It can be used several times
    # to have SOCKS5 on more than one port or on different network
    # interfaces (specify explicit source address for that).
    #
    # WARNING: The service accepts all requests, unless you use
    # SOCKS5User and make authentication mandatory. SOCKS5User
    # can be used repeatedly for a whole bunch of individual accounts.
    #
    #SOCKS5Proxy   8010
    #SOCKS5User    dave:password

    #
    # Enable to allow access from other computers
    #
    #Gateway   yes # want your friends to use this proxy?

    #
    # Useful in Gateway mode to allow/restrict certain IPs
    #
    #Allow    127.0.0.1
    #Allow    172.23.65.0/24
    #Allow    192.168.0.0/16
    #Deny     0.0.0.0/0

    #
    # Headers which should be replaced if present in the request
    # just to screw with them
    Header    User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows 98)
  </pre>
  <pre>
    Starting cntlm:
    cntlm -c /path/to/config/file
  </pre>
  <pre>
    # ~/.ssh/config
    Host <em>alias</em>
      ...
      ProxyCommand /usr/bin/corkscrew localhost <em>cntlmport</em> %h %p
  </pre>
  Then again, ssh out normally and slap on whatever options you want:
  <pre>
    ssh <em>alias</em>
  </pre>
</div>

<br />
<strong>Connection still not made?</strong>  <a href="#" onclick="$('#help').slideToggle(); return false;">[show/hide]</a>
<div id="help" style="display:none">
  I guess I hadn't thought of that setup... Try searching the internet and please let me know. I'd be interested
  in knowing your setup and what more could be needed. If I can solve, I'll add here :D<br/>
  <a href="mailto:alexc605@gmail.com">alexc605@gmail.com</a>
</div>

<hr />
<h4>2. Create the Tunnel, Two Paths</h4>

<div>
  Ok, so you've now successfully ssh'd out... What now? Well because all SSH connections are encrypted (duh), they
  aren't
  filtered, meaning you just need to direct all your connections through a tunnel!<br />
  <br />
  I'm assuming here you have a connection, and whatever ssh code is needed to be connected will be represented
  by the <code><em>hostname</em></code> identifier. This is either the <code>user@host</code> syntax or the alias
  you've got or whatever.
</div>
<strong>The SOCKS Method</strong> <a href="#" onclick="$('#socks').slideToggle(); return false;">[show/hide]</a>
<div id="socks" style="display:none">
  In this method, you use the SSH connection as a SOCKS proxy, either version 4 or 5. All the SOCKS proxy needs
  is an open port on your computer it can listen on. I like 3128.
  <pre>
      ssh -vgND <em>port</em> <em>hostname</em>
  </pre>
  <ul>
    <li><code>-v</code> means verbose, you see lots of stuff, this is optional</li>
    <li><code>-g</code> open the port for outside connections (allow your friends), this is optional</li>
    <li>
      <code>-N</code> don't execute a command on the server, just sit here (allows ctrl+c termination), this is
      optional
    </li>
    <li><code>-D</code> tells SSH to be a SOCKS proxy on the specified <em>port</em></li>
  </ul>
  <pre>
    # examples

    # Create a SOCKS proxy on port 3128 tunneled to remote.com
    ssh -D 3128 remote.com

    # Connect to remote.com with user bill and have the SOCKS
    # proxy on port 6009. The command will have verbose output
    # and nothing will be executed server-side, meaning the terminal
    # will just blather what it's doing
    ssh -vND 6009 bill@remote.com

    # Connect to remote host with alias thing in the config file
    # and have the SOCKS proxy/tunnel on port 8903. Also open
    # a port on this computer so friends may use the tunnel
    ssh -gD 8903 thing
  </pre>
  Now with a SOCKS proxy/tunnel running on your computer, just set your application's SOCKSv4 or SOCKSv5 proxy to the
  hostname of <code>localhost</code> and port of whatever you specified. If had the <code>-g</code> option, your
  friends
  can use this SOCKS proxy as well by changing the proxy hostname on their applications to your IP address.<br />
  <br />
  Congratulations, you now have free, secure, unfiltered webwebs!
</div>

<br />
<strong>The HTTP Proxy Method</strong> <a href="#" onclick="$('#http').slideToggle(); return false;">[show/hide]</a>
<div id="http" style="display:none;">
  SOCKS not good enough for you? You need shoes as well? I wouldn't go this route unless you have to. SOCKS is much
  more convenient. The only reason you'd be here is if your application doesn't have SOCKS proxy support. Well shoot.
  So the idea behind this method is to tunnel all requests to a proxy on the other end of the SSH connection. This
  way,
  applications which use an HTTP proxy, nearly all of them, will now have access to free, unfiltered internet.
  <br /><br />
  <strong>Here's what to do:</strong>

  <p>
    Get a remote proxy running. If you have a proxy known already, just skip this. Otherwise, download
    a client like Squid, and get it up and running on your server.
  </p>

  <p>Create the tunnel:</p>
  <pre>
    ssh -gvNL <em>localport</em>:<em>proxyhostname</em>:<em>proxyport</em> <em>hostname</em>
  </pre>
  <ul>
    <li><code>-v</code> means verbose, you see lots of stuff, this is optional</li>
    <li><code>-g</code> open the port for outside connections (allow your friends), this is optional</li>
    <li>
      <code>-N</code> don't execute a command on the server, just sit here (allows ctrl+c termination), this is
      optional
    </li>
    <li>
      <code>-L</code> complicated... This tells SSH to forward all requests on your machine's <em>localport</em>
      to the proxy at <em>proxyhostname</em>:<em>proxyport</em>. The proxy could be running on the server, meaning the
      hostname would be localhost, or it could be any remote proxy which the server can connect to. Either way works
      fine.
    </li>
  </ul>
  <pre>
    # examples

    # listen on 3128 on this computer and forward to a proxy on the server
    # at remote.com at port 3128
    ssh -L 3128:localhost:3128 remote.com

    # Connect to a server at remote.com with the user bill. Listen on 4000
    # on this computer and forward to a proxy on the server
    # at port 3128, with verbose output. Also, just sit in
    # the terminal, blathering what's going on.
    ssh -vNL 4000:localhost:3128 bill@remote.com

    # Connect to a server whose options are specified in the config file and
    # has the alias of remote. Also, listen on 3129 on this computer and
    # forward to the remote proxy thing.com on port 4090. Also open a port
    # on this computer to allow other connections to share this tunnel.
    ssh -gL 3129:thing.com:4090 remote
  </pre>
  Now with a http proxy running on your computer, just set your application's http proxy to the
  hostname of <code>localhost</code> and port of whatever you specified. If had the <code>-g</code> option, your
  friends
  can use this http proxy as well by changing the proxy hostname on their applications to your IP address.<br />
  <br />
  Congratulations, you now have free, secure, unfiltered webwebs!
</div>

</div>

  </div>
  <div id="sidebar" class="span-6">
    <p>
      You didn't expect links over here did you?<br />
      That's what the fancy menus are for...
    </p>
  </div>
  <div id="footer" class="span-24">
    <a href="http://validator.w3.org/check?uri=referer" class="nohighlight">
      <img src="http://www.w3.org/Icons/valid-xhtml10-blue"
           alt="Valid XHTML 1.0 Strict" height="31" width="88" />
    </a>
    <a href="http://jigsaw.w3.org/css-validator/check/referer" class="nohighlight">
      <img style="border:0;width:88px;height:31px"
           src="http://jigsaw.w3.org/css-validator/images/vcss-blue"
           alt="Valid CSS!" />
    </a>
  </div>
</div>

</body>
</html>


